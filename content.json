{"meta":{"title":"陈晨个人博客","subtitle":"记录、分享、提升","description":"一点学习笔记","author":"Ccoverflow","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello_WeiQing","slug":"Hello-WeiQing","date":"2020-09-16T14:32:10.000Z","updated":"2020-09-16T14:33:29.089Z","comments":true,"path":"2020/09/16/Hello-WeiQing/","link":"","permalink":"http://example.com/2020/09/16/Hello-WeiQing/","excerpt":"","text":"韦晴你好距离我们 2020/06/19 相识已89天加油！","categories":[],"tags":[]},{"title":"","slug":"进展报告2020:03:20","date":"2020-03-19T16:47:43.456Z","updated":"2020-03-20T11:47:42.623Z","comments":true,"path":"2020/03/20/进展报告2020:03:20/","link":"","permalink":"http://example.com/2020/03/20/%E8%BF%9B%E5%B1%95%E6%8A%A5%E5%91%8A2020:03:20/","excerpt":"","text":"陈晨2020/03/20本周工作进展：1、校园网的DNS日志通过张建强学长得到了校园网的DNS日志，量很大，每个单独日志文件2-3GB。 ![image-20200320004001000](/Users/chenchen/Library/Application Support/typora-user-images/image-20200320004001000.png) 该日志为从ELK日志分析平台提取的，是json格式，用工具重新排列单条数据可以得到比较直观的认识。 了解到目前只有这四个信息是有用的： @timestamp：时间戳 host：来源服务器 client：源IP qname：申请解析访问的域名 对于这些DNS日志，接下来思考去如何利用，目前还在查资料。 2、ELK系统安装调试软件下载安装配置环境： Centos7/64bit Java1.8 elasticsearch-6.5.4 修改一些配置项，修改完成后才能够正常启动 Chrome安装Elasticsearch-head和Restful client插件，并分别学习实现了以下操作： 创建、删除索引 插入数据 删除数据 搜索数据 3、这周和接下来几周的《web安全》课程小组作业和个人大作业花费较多时间下周工作展望： 阅读文献《Experience Report: System Log Analysis for Anomaly Detection》（作者是香港大学、香港大学深圳研究院的，2016 IEEE 27th International Symposium on Software Reliability Engineering）","categories":[],"tags":[]},{"title":"","slug":"新手理解HTML、JavaScript、CSS之间的关系","date":"2020-03-15T10:09:12.628Z","updated":"2020-03-15T10:09:12.628Z","comments":true,"path":"2020/03/15/新手理解HTML、JavaScript、CSS之间的关系/","link":"","permalink":"http://example.com/2020/03/15/%E6%96%B0%E6%89%8B%E7%90%86%E8%A7%A3HTML%E3%80%81JavaScript%E3%80%81CSS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"新手理解HTML、JavaScript、CSS之间的关系最准确的网页设计思路是把网页分成三个层次，即：结构层（HTML）、表示层（CSS）、行为层（Javascript） 一、HTML、CSS、JavaScript简介及简单分工1、什么是HTML（超文本标记语言 Hyper Text Markup Language），HTML 是用来描述网页的一种语言。 2、CSS（层叠样式表 Cascading Style Sheets），样式定义如何显示HTML元素，语法为：selector {property: value}（选择符 {属性：值}）。 3、JavaScript 是一种脚本语言，其原大吗在发往客户端运行之前不需要经过编译，而是将文本格式的字符码发送给浏览器由浏览器解释运行。 对于一个网页，HTML定义网页的结构，CSS描述网页的样子，JavaScript设置一个很经典的例子就是说，HTML就像一个人的骨骼、器官，而CSS就是人的皮肤，有了这两样也就构成了一个植物人了，加上javascript这个植物人就可以对外界刺激做出反应，可以思考、运动、可以给自己整容化妆（改变CSS）等等，成为一个活生生的人。 如果说HTML是肉身、CSS就是皮相、Javascript就是灵魂。没有Javascript，HTML+CSS是植物人，没有Javascript、CSS，单纯的HTML则是个毁容的植物人。如果说HTML是建筑师，CSS就是干装修的，Javascript是魔术师。 怎么把这三者联系在一起呢，当然得通过网页的肉身HTML，HTML是一种描述语言，它是对着浏览器描述自己的，那么它通常怎么描述具体的这个网页呢？ 123456789101112&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mycss.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;myjs.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这是一个最简单的HTML文档，这个文档对浏览器说明，我是遵循W3C标准XHTML1.0过渡版本规范（文件类型声明），我采用的编码是utf-8，我的标题是“网页标题”，描述我的模样的样式表是我同目录的mycss.css文件，与我有关的javascript代码在我同级的myks.js文件中，我的内容有一个段落，段落的内容是“这是一个段落”。 二、HTML、CSS、JavaScript发展1、HTML的版本超文本标记语言（第一版）——在1993年6月作为互联网工程工作小组（IETF）工作草案发布（并非标准）： HTML 2.0——1995年11月作为RFC 1866发布，在RFC 2854于2000年6月发布之后被宣布已经过时HTML 3.2——1997年1月14日，W3C推荐标准HTML 4.0——1997年12月18日，W3C推荐标准HTML 4.01（微小改进）——1999年12月24日，W3C推荐标准HTML 5——2014年10月28日，W3C推荐标准[4] 现在我们只说HTML 4.01和HTML5，因为2000年国际万维网联盟（W3C）公布发行了XHTML 1.0版本。XHTML 1.0是一种在HTML 4.0基础上优化和改进的的新语言，目的是基于XML应用。而XHTML 与 HTML 4.01 几乎是相同的，HTML从最初发展到XHTML的过程中变得更加的严谨，更加的灵活，与CSS结合的更好。原则上说现在能看到的大部分网页是使用HTML4或者HTML5这两个版本的。**HTML5**它是对HTML5的一次重大的修改，虽然HTML5 标准还在制定中，但不能阻碍其势不可挡的脚步，不用HTML5你就OUT了，我们经常为HTML5而HTML5，其实对于比较低端的前端（我这样的），特别是用div+CSS实现网页来说，真的改变不大。那么，HTML5的精髓在哪呢？这个得单独说一下，请见《HTML5的入门与深入理解》 2、CSS的版本1996年W3C正式推出了CSS1；1998年W3C正式推出了CSS2；CSS2.1是W3C现在正在推荐使用的；CSS3现在还处于开发中。如果说HTML的发展是一个不断修改的过程，那么CSS的发展就是一个不断补充的过程，所以在使用CSS的时候，不需要像HTML那行申明使用的标准，高版本的浏览器认识高版本的CSS定义，低版本的浏览器略过不认识的CSS定义。不管什么版本，CSS的语法很简单，选择器：{属性：属性值}，所以火爆的CSS3无外乎是扩展了选择器和属性。CSS3新增的选择器和属性请见《CSS3新增的选择器和属性》 3、JavaScript的前世今生JavaScript一种直译式脚本语言，它的解释器被称为JavaScript引擎，是浏览器的一部分，即：JavaScript是由客户端的浏览器解释执行的，所以在谈JavaScript的历史之前我们要先说一下浏览器，最早的web浏览器是创建于1991年的WorldWideWeb，后来改名为Nexus，之后出现了各类浏览器，直到1994年，网景公司（Netscape）发布了Navigator浏览器0.9版，这是历史上第一个比较成熟的网络浏览器，随后的1995年微软推出了IE浏览器，从此掀起了浏览器大战，微软采取操作系统捆绑IE浏览器，最终获得压倒性胜利，战争失利的Netscape在之后被收购、合并、解散。之后一段时间IE独领风骚，之后被Opera，Safari，Firefox，Chrome陆续瓜分掉一些市场份额，改变了一家独大的局面。 但是谈到JavaScript的历史，必须提到一个公司和一个人，那就是Netscape公司及其员工Brendan Eich，网景公司在发布了Navigator之后，急于解决浏览器与用户交互这个问题，Javascript之父Brendan Eich只用了10天的时间发明了livescript(让我辈情何以堪），由于网景高层是java的粉丝，或者说为了抱上当时热炒的java的大腿，livescript更名为javascript，Brendan Eich他的思路是： 借鉴C语言的基本语法； 借鉴Java语言的数据类型和内存管理； 借鉴Scheme语言，将函数提升到”第一等公民”（first class）的地位； 借鉴Self语言，使用基于原型（prototype）的继承机制。所以，Javascript语言实际上是两种语言风格的混合产物—-（简化的）函数式编程+（简化的）面向对象编程。 Javascript 1.0获得了巨大的成功，Netscape随后推出了1.1，之后作为竞争对手的微软在自家的 IE3 中加入了名为 JScript （名称不同是为了避免侵权）的JavaScript实现。由此JavaScript 的规范化被提上日程，1997年，以 JavaScript1.1 为蓝本的建议被提交给了 欧洲计算机制造商协会 （ECMA），ECMA牵头经过数月的努力完成了 ECMA-262 ——定义了一种名为 ECMAScript 的新脚本语言的标准。 虽然 JavaScript 和 ECMAScript 通常被人用来表达相同的意思，但 JavaScript 的含义去比 ECMA-262 中规定的多得多。一个完整的 JavaScript 实现应由三个部分组成： 核心（ECMAScript）， 描述了该语言的语法和基本对象。 文档对象模型（DOM），描述处理网页内容的方法和接口。 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口。 1995年发明了Javascript，1997年就推出了国际标准，迫切需要浏览器与用户相互的情况下，javascript发展的太快了，Javascript的规格还没来及调整，就固化了。相比之下，C语言问世将近20年之后，国际标准才颁布。Javascript有很多缺陷，但是JavaScript 在前端地位无可替代，","categories":[],"tags":[]},{"title":"","slug":"oasisi-node踩坑","date":"2020-03-04T05:17:07.117Z","updated":"2020-03-04T16:22:40.192Z","comments":true,"path":"2020/03/04/oasisi-node踩坑/","link":"","permalink":"http://example.com/2020/03/04/oasisi-node%E8%B8%A9%E5%9D%91/","excerpt":"","text":"初始化节点要初始化验证器节点，请记下您的节点将在其中运行的服务器的静态IP，并从/localhostdir/node目录中发出以下命令 ： 1STATIC_IP=&lt;YOUR-STATIC-IP&gt; #假设你的server地址为192.168.1.1，那么就把“&lt;YOUR-STATIC-IP&gt;”替换为“192.168.1.1” 123456oasis-node registry node init \\ --signer file \\ --signer.dir ../entity \\ ##这里把官网的“localhostdir”换成“..”表示上级目录的entity目录，因为按照官网的做法会因为找不到entity目录而报错 --node.consensus_address $STATIC_IP:26656 \\ --node.is_self_signed \\ --node.role validator 若按照官网的执行命令： 123456oasis-node registry node init \\ --signer file \\ --signer.dir /localhostdir/entity \\ --node.consensus_address $STATIC_IP:26656 \\ --node.is_self_signed \\ --node.role validator 则报错： 1ts=2020-03-04T05:05:58.474236972Z level=error module=cmd/registry/node caller=node.go:138 msg=&quot;failed to load entity&quot; err=&quot;file does not exist&quot; 123oasis-node registry entity update \\ --signer.dir ../entity \\ ##同上 --entity.node.descriptor node_genesis.json 若按照官网的执行命令： 123oasis-node registry entity update \\ --signer.dir /localhostdir/entity \\ --entity.node.descriptor node_genesis.json 则会报错： 1ts=2020-03-04T05:19:22.29317851Z level=error module=cmd/registry/entity caller=entity.go:153 msg=&quot;failed to load entity&quot; err=&quot;file does not exist&quot; 接下来进到server虚拟机的命令行： Running an Oasis Node on the server设置Oasis节点的工作目录在节点上运行节点之前，server我们需要确保有一个地方可以存储该节点的必要文件。 设置/serverdir目录在/serverdir目录中，我们将创建以下子目录： etc/ -这是存储配置 node/ -这是存储节点的数据 node/entity/ -这是存储节点实体的公共组件 在我的实践中若按照官网的创建命令： 1mkdir -m700 -p /serverdir/&#123;etc,node,node/entity&#125; 发现输入完也无法建立，多次尝试发现因为多了个“/”，以下是成功的尝试： 1mkdir -m700 -p serverdir/&#123;etc,node,node/entity&#125; 学到了一个命令： &lt;&lt; EOF &gt;config.yml （然后复制内容到这里） EOF#最后在输入EOF退出，系统就生成了一个config.yml文件 Configuring the Oasis Nodeconfig.yml中的 &#123;&#123; external_address &#125;&#125;应该是server连上网络的的ip，命令行输入ifconfig可看到 &#123;&#123; seed_node_address &#125;&#125;:要改成下面的这个种子地址 D14B9192C94F437E9FA92A755D3CC0341F2E87CF@34.82.86.53:26656 line 19: cannot unmarshal !!str datadir... into map[string]interface {} 启动Oasis节点通过运行以下命令来启动节点（此时在serverdir目录下）： 官网的指南： 1oasis-node --config /serverdir/etc/config.yml 这样输入会说找不到目录 应该这样： 1oasis-node --config etc/config.yml","categories":[],"tags":[]},{"title":"","slug":"如何在Oasis网络上为Quest进行节点设置","date":"2020-02-29T05:53:23.435Z","updated":"2020-02-29T08:58:01.146Z","comments":true,"path":"2020/02/29/如何在Oasis网络上为Quest进行节点设置/","link":"","permalink":"http://example.com/2020/02/29/%E5%A6%82%E4%BD%95%E5%9C%A8Oasis%E7%BD%91%E7%BB%9C%E4%B8%8A%E4%B8%BAQuest%E8%BF%9B%E8%A1%8C%E8%8A%82%E7%82%B9%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"如何在Oasis网络上为Quest进行节点设置This guide will cover setting up your nodes for The Quest, a multi-round staking competition (aka incentivized testnet) on the Oasis Network. 它假定你对命令行工具的使用有一定的基础知识。 系统要求本指南假设你有两个用于部署的不同物理机器。这些机器如下: 你的本地系统，称为localhost 远程系统，作为Oasis节点运行的系统，称为server 这样做的原因是为了确保用于设置节点的密钥得到保护。本指南不包括HSMs的使用，但是将来也要使用到它们。 创建实体（Entity）注意：本节中的所有操作都应该在本地主机localhost上完成，因为有些敏感项会创建。 创建一个工作目录在这个实体初始化过程中，我们将创建密钥和其他重要的组件，用于网络上部署节点。如果你打算使用这个生成的组件来注册实体和节点，那么在这个目录中保存和保护它们是很重要的。 注意：我们将localhost上的工作目设置为/localhostdir。 在/localhostdir中，你还要创建以下目录: entity:这将存储一个我们称为“entity”的实体。建议里面的私有内容在与internet保持断开连接的计算机上使用，这样才保证安全 目录的权限应该是rwx------ node:这将存储一个我们称为“node”的节点。这个目录的名字并不重要，它只是表示一个节点。你可以任意重命名它。该目录的私有内容将在节点本身上使用。 你应该使用Entity的私钥在系统上初始化此信息。 目录权限应该是rwx------ 关于Linux的权限说明，这里有一篇博客：Linux系统rwx权限详解 要创建目录结构，请使用以下命令: 1mkdir -m700 -p &#123;entity,node&#125; 复制创世文件最新的创世纪文件可以在Current Testnet Parameters找到。你应该下载最新genesis.json文件，将其复制到工作目录，并设置以下环境变量指向其路径： 1GENESIS_FILE_PATH=/localhostdir/genesis.json 这将在以后生成transactions时用到。 初始化实体如架构概述中所述，实体对于网络上的操作节点至关重要，因为它控制着附加到网络上的特定个人或组织的stake。在未来，我们将支持通过HSMs使用实体密钥，以确保实体密钥不会被轻易破坏。 123# 警告我们强烈建议你不要在Mainnet上使用当前进程生成的任何实体。在Public Testnet和staking competition期间，我们还建议你在没有网络连接的系统上生成实体，以便为实体密钥提供基本保护。 要初始化实体，只需从/localhostdir/entity:运行以下命令： 1oasis-node registry entity init 这将在 /localhostdir/entity中生成三个文件: entity.pem: 实体的私钥。永远不要公开这个，因为它可以用来转让STAKE。 entity.json: 这是发送到网络注册中心应用程序的未签名信息的JSON。 entity_genesis.json: 这个json对象包含了实体描述符，它已经被实体的私有密匙签名了，例如entity.pem。这意味着要共享以包含在Genesis块中。 初始化节点当节点启动时，节点将自己注册到网络。但是，为了验证自身，实体签署了与节点关联的公钥。这允许在没有上传实体的私钥到internet的情况下进行节点注册。 要初始化Validator节点，请注意将运行你的节点的服务器的静态IP，并从/localhostdir/node目录输入以下命令: 1234567STATIC_IP=&lt;YOUR-STATIC-IP&gt;oasis-node registry node init \\ --signer file \\ --signer.dir /localhostdir/entity \\ --node.consensus_address $STATIC_IP:26656 \\ --node.is_self_signed \\ --node.role validator 这个命令将创建一个Validator节点的标识，以便它可以是一个自签名节点(这就是允许自注册的原因)。 123# 注意有更多的节点初始化选项，你可以通过输入以下命令来探索:oasis-node registry node init --help 该命令将生成以下文件: consensus.pem: 节点的一致私钥。 DO NOT SHARE consensus_pub.pem: 节点的一致公钥。 identity.pem: 节点的标识私钥。 DO NOT SHARE identity_pub.pem: 节点的标识公钥。 node_genesis.json: 如果希望在网络的genesis文件中包含该节点，则需要了解该节点的详细信息。 p2p.pem: 节点的libp2p私钥。 DO NOT SHARE p2p_pub.pem: 节点的libp2p公钥。 tls_identity.pem: 用于保护gRPC连接的节点的TLS私有密钥。DO NOT SHARE tls_identity_cert.pem: 节点的TLS证书，用于保护gRPC连接。 将节点添加到实体描述符初始化节点之后，我们需要将它添加到实体描述符中，以便在节点启动时它可以正确地注册自己。 在/localhostdir/node目录下执行以下命令: 123oasis-node registry entity update \\ --signer.dir /localhostdir/entity \\ --entity.node.descriptor node_genesis.json 这将更新entity.json中的实体描述符，并随后更新包含签名实体描述符的entity_genesis.json文件。 初始化其他节点在Public Testnet的时候，网络将只有Validator，没有其他committees(没有计算，没有密钥管理，没有存储，等等)。 此时，本文档不包括配置单个Validator之外的任何东西的说明。 如果你想创建更多的Validator节点，你可以简单地重复上面的过程来初始化额外节点的构件，只需适当地重命名与特定节点相关的内容。 12# 注意每个节点至少需要网络定义的最小堆栈数量(此时为100个令牌)。 在服务器上运行Oasis节点设置Oasis节点的工作目录在服务器上运行节点之前，我们需要确保有地方存储节点所需的文件。 12# 注意我们将在整个文档中将服务器的工作目录引用为/serverdir。 设置 /serverdir 目录在/serverdir 目录中，我们将创建以下子目录: etc/ - 这是用来存储配置的 node/ - 用来存储节点的数据 node/entity/ - 这是用来存储节点实体的公共组件的 你可以通过执行以下命令来创建这个目录结构: 1mkdir -m700 -p /serverdir/&#123;etc,node,node/entity&#125; 从 /localhostdir复制节点构件为了使节点注册正常工作(如/localhostdir/entity.json中定义的那样)，你必须复制在初始化节点部分中生成的节点组件。为此，通过安全通道(例如SSH)将以下文件从/localhostdir/node上传到/serverdir/node: consensus.pem consensus_pub.pem identity.pem identity_pub.pem p2p.pem p2p_pub.pem tls_identity.pem tls_identity_cert.pem 复制后，请确保所有这些文件都具有 0600 权限，即只有其所有者具有 read 和 write 权限。 为此，执行以下命令: 1chmod -R 600 /serverdir/node/*.pem 1234# 重要你可能已经注意到，其中一些文件在初始化节点部分中被列出为 DO NOT SHARE 将来，应该从HSM生成并引用这些密钥。然而，在HSM支持实现之前，这些密钥应该尽可能地在server上保证安全。 从 /localhostdir复制公共实体构件我们还需要在 server上显示/localhostdir中的公共实体组件。 将本地主机上的 /localhostdir/entity/entity.json文件复制到server上的/serverdir/node/entity/entity.json 目录 将Genesis文件复制到server最新的Genesis文件可以在 Current Testnet Parameters中找到。你应该下载最新的genesis.json 文件并将其复制到server上的/serverdir/etc/genesis.json 路径下。 配置Oasis节点在运行Oasis节点时，有多种可用的选项。下面的YAML文件是网络上Validator节点的基本配置。 在使用此配置之前，你应该收集以下信息来替换配置文件中出现的 &#123; &#123; var_name &#125; &#125;变量: &#123; &#123; external_address &#125; &#125;: 注册此节点时使用的外部IP。 12# 注意如果你使用的是Sentry Node，则应该使用该机器的公共IP。 &#123; &#123; seed_node_address &#125; &#125;: 种子节点地址的形式为ID@IP:port。 你可以在 Current Testnet Parameters中找到当前的 Oasis Seed Node的地址。 要使用此配置，请将其保存在/serverdir/etc/config.yml文件中，并将其作为--config标志的参数传递给oasis-node命令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990### Oasis Node Configuration## This file&#x27;s contents are derived from the command line arguments found in the# root command of the oasis-node binary. For more information, execute:## oasis-node --help## Settings on the command line that are separated by a dot all belong to the# same nested object. For example, &quot;--foo.bar.baz hello&quot; would translate to:## foo:# bar:# baz: hello### Set this to where you wish to store node data. The node&#x27;s artifacts# should also be located in this directory.datadir: /serverdir/node# Logging.## Per-module log levels are defined below. If you prefer just one unified log# level, you can use:## log:# level: debuglog: level: # Per-module log levels. Longest prefix match will be taken. Fallback to # &quot;default&quot;, if no match. default: debug tendermint: warn tendermint/context: error format: JSON # By default logs are output to stdout. If you would like to output logs to # a file, you can use: # # file: /var/log/oasis-node.log# Genesis.genesis: # Path to the genesis file for the current version of the network. file: /serverdir/etc/genesis.json# Worker configuration.worker: registration: # In order for the node to register itself, the entity.json of the entity # used to provision the node must be available on the node. entity: /serverdir/node/entity/entity.json# Consensus backend.consensus: # Setting this to true will mean that the node you&#x27;re deploying will attempt # to register as a validator. validator: true# Tendermint backend configuration.tendermint: abci: prune: # WARNING: Use this carefully. Pruning blockchain state is resource intensive. # However, running with pruning disabled means you will eventually fill all # storage on your node. # See https://github.com/oasislabs/oasis-core/issues/2432 for more details. # # This configuration would cause your node to retain state from only the # latest 86400 blocks: # strategy: keep_n # num_kept: 86400 # strategy: none core: listen_address: tcp://0.0.0.0:26656 # The external IP that is used when registering this node to the network. # NOTE: If you are using the Sentry node setup, this option should be # omitted. external_address: tcp://&#123;&#123; external_address &#125;&#125;:26656 db: backend: badger debug: addr_book_lenient: false # List of seed nodes to connect to. # NOTE: You can add additional seed nodes to this list if you want. p2p: seed: - &quot;&#123;&#123; seed_node_address &#125;&#125;&quot; 确保适当的权限只有运行Oasis节点的进程的所有者才能访问/serverdir/node目录中的文件。oasis-node二进制文件确保该节点使用的文件拥有尽可能少的特权，这样你就不会在操作节点时不小心搬起石头砸自己的脚。 为了确保设置了正确的权限，我们建议运行以下命令来删除所有非所有者的读/写/执行权限: 1chmod -R go-r,go-w,go-x /serverdir 注意 需要说明的是，oasis-node binary二进制文件需要以下权限: 700 用于 /serverdir/node 目录 700 用于 /serverdir/node/entity 目录 600 用于所有的 *.pem 文件 启动Oasis节点 123# 警告在以前的文档版本中，我们要求你在运行的Docker容器上打开端口42261。在某些配置中，我们注意到这个端口暴露于外部世界。这是不需要的，应该立即删除。保持那个港口开放是一种临时措施，通常是不安全的。请将该端口对公众关闭，不要以任何方式绑定到它。 你可以通过运行以下命令来启动节点: 1oasis-node --config /serverdir/etc/config.yml 123# 注意默认情况下，Oasis节点被配置为在前台运行。我们建议你在systemd或Supervisor等流程管理器中配置和使用它。 验证与网络的连接作为启动服务器进程的一部分，缺省情况下，oasis-node二进制将在节点的datadir中设置一个内部unix套接字。此套接字可用于与节点通信并查询有关网络的详细信息。 运行以下命令: 1oasis-node registry entity list -a unix:/serverdir/node/internal.sock 如果这个命令失败，你将收到一个非零的退出码，你很可能没有连接到网络。如果它工作正常，它应该响应输出如下，但也可能有更多的内容： 12345CVzqFIADD2Ed0khGBNf4Rvh7vSNtrL1ULTkWYQszDpc=C5z1jB+FHB/QgtTITr6NKWpUs9QHwD11CG3v8tmuJ0g=DPbZomOIleFrvcJBZPl7y/wEB1w9Q569vAbb6Krl9fE=DVobZ8bWlOv2J6oHO0uITr5FPO5rIY2irdPNhByprHk=D2hqhJcmZnBmhw9TodOdoFPAjmRkpRatANCNHxIDHgA= 到达连接的节点后，可以继续下一节，因为你的节点还没有在Oasis Testnet上注册为Validator。 注册Testnet Tokens12# 注意如果你在2019/01/13 @ 00:00 UTC之前为任务提交了有效的实体包，则此步骤是不必要的。在这种情况下，你的实体将包含在Genesis文件中。 为了参与到Testnet中，你需要有一些tokens。你将使用这些tokens来注册你的实体并在网络上stake。 为了得到代币，你需要在此表格上注册。填写表单时，它将要求你的实体的公钥。这与您的实体的帐户ID相同，可以在/localhostdir/entity/entity JSON文件中的id键中找到。 例子 在以下 entity.json 文件中， 实体的公钥为TszGIrC1X08czcik0DgAnmGPzjf8pfQ47bgrjpTmbro=. 12345678&#123; &quot;id&quot;: &quot;TszGIrC1X08czcik0DgAnmGPzjf8pfQ47bgrjpTmbro=&quot;, &quot;nodes&quot;: [ &quot;C93lKVNNkca3Oo9m1exiz22NvMBxxYjkyBrt2+eFAds=&quot; ], &quot;registration_time&quot;: 1573585972, &quot;allow_entity_signed_nodes&quot;: false&#125; 填写完表格后，等待电子邮件通知你已经获得资金，然后再继续下一步。以下部分假设你已经获得了funded。 Staking 和注册注意：如果你的实体在Genesis文件中列出，则不必执行此步骤。 注意：如果你以前提交过标记或注册表事务，那么你的nonce可能与示例中使用的nonce不同。如果你不确定，请立即使用本指南检查你的帐户。 一旦你获得了资金，你可以通过注册你的实体和节点来完成将你的节点连接到网络的过程，如下所述： 检查你的节点是否同步在进行任何事务之前，必须确保节点是同步的。在服务器上调用这个命令: 1oasis-node control is-synced -a unix:/serverdir/node/internal.sock 如果你的节点是同步的，上面的命令应该输出： 1node completed initial syncing 如果你的节点尚未同步，则需要等待才能继续。 在 localhost上生成一个Staking（托管）事务你的实体的私钥应该在localhost上与internet断开连接。因此，你需要在localhost上生成以下事务。 警告：实体的私钥用于授权你的staking帐户上的交易。因此，它不应该出现在在线server上。 对于Testnet，当前注册实体和将节点注册为Validator所需的最stake是100个令牌。因此，我们将生成一个托管事务，托管你自己实体上的100个令牌。 注意：Oasis节点的标记应用程序将标记标记的操作称为“托管”。 在生成托管事务之前，你需要设置以下环境变量： GENESIS_FILE_PATH: 指向 localhost中Genesis文件的路径 即：/localhostdir/genesis.json`。 ENTITY_DIR_PATH: 本地主机上实体组件目录的路径，即：/localhostdir/entity/。 OUTPUT_TX_FILE_PATH：包含输出的已签名事务的文件的路径。 对于本指南，我们将使用/localhostdir/signed-escrow.tx. ACCOUNT_ID：实体的ID（public key）。 注意：你可以在 entity.json 文件的ID字段中找到你的实体 id 。 然后执行以下命令： 12345678910oasis-node stake account gen_escrow \\ --genesis.file $GENESIS_FILE_PATH \\ --signer file \\ --signer.dir $ENTITY_DIR_PATH \\ --stake.escrow.account $ACCOUNT_ID \\ --stake.amount 100000000000 \\ --transaction.file $OUTPUT_TX_FILE_PATH \\ --transaction.fee.gas 1000 \\ --transaction.fee.amount 1 \\ --transaction.nonce 0 注意：选项--stake.amount 看起来是一个非常大的数字，但它实际上相当于Testnet上的100个Token，因为用于跟踪帐户余额的每个单位值是1x10^-9个令牌 生成 Entity Registration Transaction提交你的托管帐户后，你需要注册你的实体，使你的节点注册正确。你可以在提交托管事务后执行此过程。然而，为了节省步骤，我们在生成register事务之前，需要设置以下环境变量： GENESIS_FILE_PATH:本地主机上的Genesis文件的路径，即/localhostdir/genesis.json. ENTITY_DIR_PATH: 本地主机上实体工件目录的路径，即/localhostdir/entity/. OUTPUT_REGISTER_TX_FILE_PATH: 包含输出的签名事务的文件的路径。 对于本指南，我们将使用 /localhostdir/signed-register.tx. 然后执行以下命令： 12345678oasis-node registry entity gen_register \\ --genesis.file $GENESIS_FILE_PATH \\ --signer file \\ --signer.dir $ENTITY_DIR_PATH \\ --transaction.file $OUTPUT_REGISTER_TX_FILE_PATH \\ --transaction.fee.gas 1000 \\ --transaction.fee.amount 1 \\ --transaction.nonce 1 在服务器上提交事务为了完成标记过程，我们需要将生成的托管和注册表事务从脱机本地主机复制到服务器并提交它们。 为此，请遵循以下步骤: 将本地主机上的 /localhostdir/signed-escrow.tx文件复制到服务器上的/serverdir/signed-escrow.tx。 将本地主机上的 /localhostdir/signed-register.tx 文件复制到服务器上/serverdir/signed-register.tx 。 通过 oasis-node consensus submit_tx 子命令提交两个事务: 123456oasis-node consensus submit_tx \\ --transaction.file /serverdir/signed-escrow.tx \\ -a unix:/serverdir/node/internal.sockoasis-node consensus submit_tx \\ --transaction.file /serverdir/signed-register.tx \\ -a unix:/serverdir/node/internal.sock 检查你的节点是否正确注册要确保你的节点作为网络上的Validator被正确连接，你可以运行以下命令： 1oasis-node registry node is-registered -a unix:/serverdir/node/internal.sock 如果你的节点已注册，上面的命令应该输出： 1node is registered You’re a Validator!如果你已经做到了这一点，那么你已经正确地将你的节点连接到网络，并且你现在是Public Testnett上的Validator。","categories":[],"tags":[]},{"title":"从0开始搭建自己的个人博客","slug":"从0开始搭建自己的个人博客","date":"2020-02-28T15:14:15.000Z","updated":"2020-09-16T13:52:05.150Z","comments":true,"path":"2020/02/28/从0开始搭建自己的个人博客/","link":"","permalink":"http://example.com/2020/02/28/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"从0开始搭建自己的个人博客搭建个人博客的过程中肯定会出现各种问题，不必畏惧，网上解决方案很多，大不了重来一次 先把博客搭建起来，再考虑内容和页面美观和交互效果等 这里用的是HEXO博客框架 一、部署环境安装Node.js和npm下载网址:Node.js官方网址 进入官网下载LTS版本并安装，此安装会把Node.js和npm一并安装 打开终端输入sudo su，输入密码后进入root用户出现： 1sh-3.2# 在终端检查Node.js和npm是否安装成功 1234sh-3.2# node -v v12.14.0 #说明node.js已经安装成功sh-3.2# npm -v6.13.4 #说明npm已经安装成功 安装HEXO博客框架借助npm包管理器来安装，由于npm默认镜像源在国内安装网速受限，所以先用npm安装cnpm，输入命令 1sh-3.2# npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 等待安装成功，安装完成后查看版本 12345678sh-3.2# cnpm -vcnpm@6.1.1 (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;cnpm&#x2F;lib&#x2F;parse_argv.js)npm@6.14.1 (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;cnpm&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;npm.js)node@12.14.0 (&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node)npminstall@3.27.0 (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;cnpm&#x2F;node_modules&#x2F;npminstall&#x2F;lib&#x2F;index.js)prefix&#x3D;&#x2F;usr&#x2F;local darwin x64 19.3.0 registry&#x3D;https:&#x2F;&#x2F;r.npm.taobao.org 输入命令用cnpm安装HEXO博客框架 1sh-3.2# cnpm install -g hexo-cli 等待安装完成，同样使用命令hexo -v验证安装成功与否 建立一个存放博客文件的空文件夹blog，并进入 12sh-3.2# mkdir blogsh-3.2# cd blog 接下来的工作都是在blog中进行各种命令操作 二、初始化个人博客初始化HEXO 1sh-3.2# sudo hexo init 经过一段时间等待初始化完成，输入ls -l命令可以查看到目录结构 12345678910111213sh-3.2# ls -ltotal 384drwxr-xr-x 13 root staff 416 2 28 22:07 .deploy_git-rw-r--r-- 1 root staff 65 2 28 17:51 .gitignore-rw-r--r-- 1 root staff 2820 2 28 20:34 _config.yml-rw-r--r-- 1 root staff 46349 2 28 22:07 db.jsondrwxr-xr-x 268 root staff 8576 2 28 20:24 node_modules-rw-r--r-- 1 root staff 131757 2 28 19:54 package-lock.json-rw-r--r-- 1 root staff 662 2 28 19:54 package.jsondrwxr-xr-x 12 root staff 384 2 28 22:07 publicdrwxr-xr-x 5 root staff 160 2 28 17:51 scaffoldsdrwxr-xr-x 3 root staff 96 2 28 17:51 sourcedrwxr-xr-x 4 root staff 128 2 28 18:35 themes 启动博客 123sh-3.2# hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 这时候他会在本地4000端口启动博客，在浏览器输入localhost:4000 可以看到博客已经成功生成在本地 三、写博客12sh-3.2# hexo new &quot;我的第一篇博客文章&quot;INFO Created: &#x2F;Users&#x2F;chenchen&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;我的第一篇博客文章.md #可以看到INFO信息提示的文件生成目录 输入cd source/_posts进入该目录再在命令行输入ls就可以看到博客文件，然后我们输入 1sh-3.2# vim 我的第一篇博客文章 编辑文章，markdown格式编辑 123456789101112131415161718192021---title: 我的第一篇博客date: 2020-02-28 18:01:04tags:---## 第一章内容---## 第二章内容---## 参考文献www.xxx.com wq保存退出。 此时我们所在位置为_posts目录 12sh-3.2# pwd&#x2F;Users&#x2F;chenchen&#x2F;blog&#x2F;source&#x2F;_posts 接下来我们要进入blog目录 *cd ../..*进入blog目录在这个目录输入一些hexo命令 1sh-3.2# hexo g #g 顾名思义generate生成 HEXO启动 1sh-3.2# hexo s #start 浏览器输入localhost:4000就可以看到第一篇博客的成功生成 四、把个人博客部署到远端接下来说明如何将我们自己的博客部署到GitHub上公开访问 假设已经注册好GitHub账户 进入GitHub官网并登陆账户 点击左上角**+**号，出现一个小菜单 点击 New repository 在**Repository name **一栏输入新建远端博客的域名 域名格式：github账户名.github.io 填好域名后其他可以默认不填，点击Create repository 接下来需要先在命令行安装git插件回到刚才的命令行输入 1sh-3.2# cnpm install --save hexo-deployer-git 安装完成后在进入blog目录设置配置文件_config.yml 1sh-3.2# vim _config.yml 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #此处添加&quot;git&quot; repo: https://github.com/github账户名/github账户名.github.io.git #此处添加&quot;repo:刚才创建的仓库地址&quot; branch: master #此处添加&quot;branch: master&quot;，注意空格！！ config文件修改完成，**:wq**保存退出 使用命令部署到远端1sh-3.2# hexo d 接下来需要输入GitHub账号密码就可以成功的部署到远端 _posts/node_modules/ansi-styles/readme.md","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"http://example.com/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"Mac环境下GitHub SSH keys的生成配置","slug":"Mac环境下GitHub-SSH-keys的生成配置","date":"2020-02-28T13:53:13.000Z","updated":"2020-02-28T14:00:16.220Z","comments":true,"path":"2020/02/28/Mac环境下GitHub-SSH-keys的生成配置/","link":"","permalink":"http://example.com/2020/02/28/Mac%E7%8E%AF%E5%A2%83%E4%B8%8BGitHub-SSH-keys%E7%9A%84%E7%94%9F%E6%88%90%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Mac下GitHub的SSH keys 生成配置进入Mac终端，输入命令1$ cd ~/.ssh #检查本机的ssh密钥 如果提示No such file or directory 说明你是第一次使用 接下来生成新的SSH key：123456789$ ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;Users&#x2F;your_user_directory&#x2F;.ssh&#x2F;id_rsa):&lt;回车&gt;Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;&lt;如不想设置密码可直接回车表示为空&gt;Enter same passphrase again:&lt;再次输入加密串&gt;&lt;接着回车确认&gt;Your identification has been saved in &#x2F;Users&#x2F;你的名字&#x2F;.ssh&#x2F;id_rsa).Your public key has been saved in &#x2F;Users&#x2F;你的名字&#x2F;.ssh&#x2F;id_rsa.pub.The key fingerprint is:xx:xx:xx:xx:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a &quot;你的邮箱地址&quot; 最后出现类似长方形的字符画即表示成功 此处可能会遇到的几个问题： 无法看到**.ssh**文件解决方法：显示隐藏文件即可 如果你要设置密码，输入密码时是不会有***字样的，直接输入就可以了##将SSH key添加到GitHub中 1$ cd ~&#x2F;.ssh #进入本机的ssh密钥目录 输入 1$ ls 可以看到目录下有id_rsa.pub 输入 1$ cat id_rsa.pub 接下来会出现一串以ssh-rsa开头的字符串例如： ssh-rsa AXXXB3NzaC1yc2XXXiL+ytQ/r8cwouFVky9gyezQQw98Lw7Ji9BCljS28mGT7+/8BzxEjuxYXXXXXXXO5YQOTJkefjSZxusS71YwsQgEsLq3jx4uyDjc/DS3R5lWSydhDoXLdKQWEzd6Oe1COUzaH8+NA8TKQvYUm0gghXXXXXXY5J/M4tN4Pr73VKe5BzHytcvMkKk94Zst0Dvy707GJdOt30dJ7N &#88;&#88;&#x58;&#64;&#x58;&#88;&#88;&#x4d;&#x61;&#x63;&#x42;&#x6f;&#x6f;&#x6b;&#45;&#x50;&#x72;&#111;&#46;&#x6c;&#x6f;&#99;&#97;&#x6c; 将这段字符串复制，进入GitHub主业，点击右上角头像进入settings，选择SSH and GPG keys，再点击New SSH Key。将内容复制进key，title可以为空。最后Add SSH key，点击后会让你输入你的GitHub账户密码，正确输入后一般来说就成功了 通过如下命令进行测试是否成功1$ ssh -T git@GitHub.com #全部复制，无需更改 接下来会出现 12345The authenticity of host &#39;github.com (xx.x50.177.x23)&#39; can&#39;t be established.RSA key fingerprint is SHA256:nxxxxxxxxxxxxpRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes&#x2F;no)? yes #这里填入yesWarning: Permanently added &#39;github.com,13.250.177.223&#39; (RSA) to the list of known hosts.Hi XXXX! You&#39;ve successfully authenticated, but GitHub does not provide shell access. #成功！ 完成","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-02-28T10:01:04.000Z","updated":"2020-02-28T10:05:52.421Z","comments":true,"path":"2020/02/28/我的第一篇博客/","link":"","permalink":"http://example.com/2020/02/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一章内容 第二章内容 参考文献www.xxx.com","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-02-28T09:51:23.178Z","updated":"2020-02-28T09:51:23.178Z","comments":true,"path":"2020/02/28/hello-world/","link":"","permalink":"http://example.com/2020/02/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"http://example.com/tags/%E8%AE%B0%E5%BD%95/"}]}